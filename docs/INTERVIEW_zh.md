# 面试准备指南

## 项目概述
**高性能 C++ 键值缓存**
一个线程安全、持久化的键值存储系统，支持自定义二进制协议、LRU 淘汰策略和高并发。

## 核心设计决策

### 1. 为什么选择 C++20?
- **性能**: 零开销抽象和手动内存管理控制。
- **现代特性**: 使用 `std::unique_ptr` 进行所有权管理 (RAII)，`std::optional` 用于清晰的 API 返回，以及 `std::thread` 用于并发。
- **Concepts**: (如果使用了) 在模板上强制类型约束。

### 2. 并发模型
- **演进**: 最初使用单个 `std::mutex` 保护 `LRUCache`。
- **瓶颈**: 性能分析显示在高负载下单个互斥锁存在高竞争。
- **解决方案**: 实现了 **分片锁 (Sharded Locking)**。
  - 键被哈希到 $N$ 个分片之一 (默认 16)。
  - 每个分片都有自己的互斥锁和 LRU 列表。
  - 降低了锁的粒度，允许并行访问不同的分片。
  - **结果**: 16 线程下实现了 8.4 倍的加速。

### 3. 网络架构
- **模型**: 使用 `epoll` (边缘触发) 的 Reactor 模式。
- **为什么选择 Epoll?**: 与每连接一线程相比，能更高效地处理数千个并发连接。
- **非阻塞 I/O**: 确保主循环永远不会因等待数据而阻塞。

### 4. 持久化 (AOF)
- **机制**: 追加写文件 (Append-Only File)。每次写入 (`SET`, `DEL`) 都会追加到日志文件中。
- **恢复**: 启动时，服务器读取 AOF 并重放命令以重建内存状态。
- **权衡**: 写入更快 (顺序 I/O) vs 恢复更慢 (重放时间)。

## 常见面试问题

### Q: 你的 LRU 实现是如何工作的？
**A:** 它结合使用了 `std::list` (双向链表) 和 `std::unordered_map`。
- **Map**: 存储 `Key -> List Iterator`。允许 O(1) 访问。
- **List**: 存储 `{Key, Value}` 对，按使用顺序排列。
- **Get**: 在 map 中查找，将节点移动到链表头部。
- **Put**: 查找。如果存在，更新并移动到头部。如果不存在，插入头部。如果已满，移除尾部 (最近最少使用) 并从 map 中删除。

### Q: 为什么选择二进制协议而不是 JSON/HTTP？
**A:**
- **效率**: 更小的负载大小 (无字段名，紧凑的整数)。
- **解析速度**: 固定大小的头部允许直接转换/读取，避免了昂贵的字符串解析。
- **结构**:
  - `Magic` (2 字节): 完整性检查。
  - `Version` (1 字节): 面向未来。
  - `Command` (1 字节): 操作类型。
  - `KeyLen/ValueLen` (4 字节): 显式长度以确保安全读取。

### Q: 在分片设计中如何处理 "热点键" (Hot Keys)？
**A:**
- **问题**: 如果 90% 的时间都在访问同一个键，那么该特定分片的锁就会成为瓶颈，抵消了分片的好处。
- **解决方案**:
  1.  **本地缓存**: 客户端侧缓存。
  2.  **只读副本**: 如果是读多写少，将热点键复制到多个分片或节点。

### Q: 如何使用 AOF 确保数据一致性？
**A:**
- 目前，我定期刷新到磁盘。在生产系统中，我会使用 `fsync` 策略 (Always, EverySec, No) 来平衡安全性与性能。
- **崩溃恢复**: AOF 是事实日志。重放它可以恢复最后的一致状态。

### Q: 你遇到的最难的 Bug 是什么？
**A:** (示例)
- **场景**: 过渡到分片 LRU 期间的死锁或竞争条件。
- **修复**: 确保操作严格只锁定所需的分片，并且从不通过同时持有多个分片锁 (或者如果需要，按确定性顺序获取)。

## 性能数据 (背下来)
- **单线程**: ~34ns 延迟。
- **16 线程 (全局锁)**: ~5369ns (高竞争)。
- **16 线程 (分片)**: ~635ns。
- **提升**: ~8.4 倍加速。
